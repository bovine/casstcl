
/*
 *--------------------------------------------------------------
 *
 * casstcl_obj_to_cass_batch_type -- lookup a string in a Tcl object
 *   to be one of the batch_type strings for CassBatchType and set
 *   a pointer to a passed-in CassBatchType value to the corresponding
 *   CassBatchType such as CASS_BATCH_TYPE_LOGGED, etc
 *
 * Results:
 *      ...cass batch type gets set
 *      ...a standard Tcl result is returned
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
int
casstcl_obj_to_cass_batch_type (Tcl_Interp *interp, Tcl_Obj *tclObj, CassBatchType *cassBatchType) {
    int                 batchTypeIndex;

    static CONST char *batchTypes[] = {
        "logged",
        "unlogged",
        "counter",
        NULL
    };

    enum batchTypes {
        OPT_LOGGED,
        OPT_UNLOGGED,
        OPT_COUNTER
	};

    // argument must be one of the subOptions defined above
    if (Tcl_GetIndexFromObj (interp, tclObj, batchTypes, "batch_type",
        TCL_EXACT, &batchTypeIndex) != TCL_OK) {
        return TCL_ERROR;
    }

    switch ((enum batchTypes) batchTypeIndex) {
        case OPT_LOGGED: {
			*cassBatchType = CASS_BATCH_TYPE_LOGGED;
			break;
		}

        case OPT_UNLOGGED: {
			*cassBatchType = CASS_BATCH_TYPE_UNLOGGED;
			break;
		}

        case OPT_COUNTER: {
			*cassBatchType = CASS_BATCH_TYPE_COUNTER;
			break;
		}
	}

	return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * casstcl_batch_type_to_batch_type_string -- given a CassBatchType
 *   code return a string corresponding to the CassBatchType constant
 *
 * Results:
 *      returns a pointer to a const char *
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
const char *casstcl_batch_type_to_batch_type_string (CassBatchType cassBatchType)
{
	switch (cassBatchType) {
		case CASS_BATCH_TYPE_LOGGED:
			return "logged";

		case CASS_BATCH_TYPE_UNLOGGED:
			return "unlogged";

		case CASS_BATCH_TYPE_COUNTER:
			return "counter";

		default:
			return "unknown";
	}
}

/*
 *--------------------------------------------------------------
 *
 *   casstcl_batch_command_to_batchClientData -- given a batch command name,
 *   find it in the interpreter and return a pointer to its batch client
 *   data or NULL
 *
 * Results:
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
casstcl_batchClientData *
casstcl_batch_command_to_batchClientData (Tcl_Interp *interp, char *batchCommandName)
{
	Tcl_CmdInfo batchCmdInfo;

	if (!Tcl_GetCommandInfo (interp, batchCommandName, &batchCmdInfo)) {
		return NULL;
	}

	casstcl_batchClientData *bcd = (casstcl_batchClientData *)batchCmdInfo.objClientData;
    if (bcd->cass_batch_magic != CASS_BATCH_MAGIC) {
		return NULL;
	}

	return bcd;
}


/*
 *----------------------------------------------------------------------
 *
 * casstcl_createBatchObjectCommand --
 *
 *    given a casstcl_sessionClientData pointer, an object name (or "#auto"),
 *    and a CASS_BATCH_TYPE, create a corresponding batch object command
 *
 * Results:
 *    A standard Tcl result
 *
 *----------------------------------------------------------------------
 */
int
casstcl_createBatchObjectCommand (casstcl_sessionClientData *ct, char *commandName, CassBatchType cassBatchType)
{
	// allocate one of our cass client data objects for Tcl and configure it
	casstcl_batchClientData *bcd = (casstcl_batchClientData *)ckalloc (sizeof (casstcl_batchClientData));
	Tcl_Interp *interp = ct->interp;

	bcd->cass_batch_magic = CASS_BATCH_MAGIC;
	bcd->ct = ct;
	bcd->batch = cass_batch_new (cassBatchType);
	bcd->batchType = cassBatchType;
	bcd->consistency = CASS_CONSISTENCY_ONE;
	bcd->count = 0;

#define BATCH_STRING_FORMAT "batch%lu"
	// if commandName is #auto, generate a unique name for the object
	int autoGeneratedName = 0;
	if (strcmp (commandName, "#auto") == 0) {
		static unsigned long nextAutoCounter = 0;
		int baseNameLength = snprintf (NULL, 0, BATCH_STRING_FORMAT, nextAutoCounter) + 1;
		commandName = ckalloc (baseNameLength);
		snprintf (commandName, baseNameLength, BATCH_STRING_FORMAT, nextAutoCounter++);
		autoGeneratedName = 1;
	}

	// create a Tcl command to interface to the batch object
	bcd->cmdToken = Tcl_CreateObjCommand (interp, commandName, casstcl_batchObjectObjCmd, bcd, casstcl_batchObjectDelete);
	// set the full name to the command in the interpreter result
	Tcl_GetCommandFullName(interp, bcd->cmdToken, Tcl_GetObjResult (interp));
	if (autoGeneratedName == 1) {
		ckfree(commandName);
	}

	return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * casstcl_batchObjectObjCmd --
 *
 *    dispatches the subcommands of a casstcl batch-handling command
 *
 * Results:
 *    stuff
 *
 *----------------------------------------------------------------------
 */
int
casstcl_batchObjectObjCmd(ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    int         optIndex;
	casstcl_batchClientData *bcd = (casstcl_batchClientData *)cData;
	int resultCode = TCL_OK;

    static CONST char *options[] = {
        "add",
		"upsert",
		"count",
        "consistency",
		"reset",
        "delete",
        NULL
    };

    enum options {
        OPT_ADD,
        OPT_UPSERT,
		OPT_COUNT,
        OPT_CONSISTENCY,
		OPT_RESET,
		OPT_DELETE
    };

    /* basic validation of command line arguments */
    if (objc < 2) {
        Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?args?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
		return TCL_ERROR;
    }

    switch ((enum options) optIndex) {
		case OPT_ADD: {
			CassStatement* statement = NULL;
			if (casstcl_make_statement_from_objv (bcd->ct, objc, objv, 2, &statement) == TCL_ERROR) {
				return TCL_ERROR;
			}

			CassError cassError = cass_batch_add_statement (bcd->batch, statement);
			cass_statement_free (statement);

			if (cassError == CASS_OK) {
				bcd->count++;
			} else {
				Tcl_AppendResult (interp, " while adding statement to batch", NULL);
				return casstcl_cass_error_to_tcl (bcd->ct, cassError);
			}

			break;
		}

		case OPT_UPSERT: {
			CassStatement* statement = NULL;

			resultCode = casstcl_make_upsert_statement_from_objv (bcd->ct, objc - 2, &objv[2], NULL, &statement);

			if (resultCode != TCL_ERROR) {
//printf("calling cass_batch_add_statement\n");
				CassError cassError;
				cassError = cass_batch_add_statement (bcd->batch, statement);
				cass_statement_free (statement);
//printf("returned from cass_batch_add_statement, cassError %d\n", cassError);

				if (cassError == CASS_OK) {
				bcd->count++;
				} else {
					return casstcl_cass_error_to_tcl (bcd->ct, cassError);
				}
			}

			break;
		}

		// count - return a count of rows in the batch
		case OPT_COUNT: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			Tcl_SetObjResult (interp, Tcl_NewIntObj (bcd->count));
			break;
		}


		case OPT_CONSISTENCY: {
			CassConsistency cassConsistency;

			if ((objc < 2) || (objc > 3)) {
				Tcl_WrongNumArgs (interp, 2, objv, "?consistency?");
				return TCL_ERROR;
			}

			if (objc == 2) {
				Tcl_SetObjResult (interp, Tcl_NewStringObj (casstcl_cass_consistency_to_string (bcd->consistency), -1));
				return TCL_OK;
			}

			if (casstcl_obj_to_cass_consistency(bcd->ct, objv[2], &cassConsistency) == TCL_ERROR) {
				return TCL_ERROR;
			}

			CassError cassError = cass_batch_set_consistency (bcd->batch, cassConsistency);
			bcd->consistency = cassConsistency;
			if (cassError != CASS_OK) {
				return casstcl_cass_error_to_tcl (bcd->ct, cassError);
			}
			break;
		}

		case OPT_RESET: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			cass_batch_free (bcd->batch);
			bcd->batch = cass_batch_new (bcd->batchType);
			bcd->count = 0;
			CassError cassError = cass_batch_set_consistency (bcd->batch, bcd->consistency);
			if (cassError != CASS_OK) {
				return casstcl_cass_error_to_tcl (bcd->ct, cassError);
			}

			break;
		}

		case OPT_DELETE: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			if (Tcl_DeleteCommandFromToken (bcd->ct->interp, bcd->cmdToken) == TCL_ERROR) {
				resultCode = TCL_ERROR;
			}
			break;
		}
    }
    return resultCode;
}

/*
 *--------------------------------------------------------------
 *
 * casstcl_batchObjectDelete -- command deletion callback routine.
 *
 * Results:
 *      ...destroys the batch object.
 *      ...frees memory.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
void
casstcl_batchObjectDelete (ClientData clientData)
{
    casstcl_batchClientData *bcd = (casstcl_batchClientData *)clientData;

    assert (bcd->cass_batch_magic == CASS_BATCH_MAGIC);

	cass_batch_free (bcd->batch);
    ckfree((char *)clientData);
}